---
title: "Introdução ao R"
description: |
  Uma introdução absurdamente breve
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 3. Algo sobre o R Base

## 3.1 Introdução

### 3.1.1 Palavras iniciais sobre o R Base

De acordo com a [página oficial](https://www.r-project.org/about.html), o `R` é 
uma **linguagem** e **ambiente** de programação.
Por ser um *ambiente de programação*, fornece um espaço planejado e coerente 
para que as amplas variedades de testes e ferramentas estatísticas sejam 
implementadas.
O `R` também é um *software* livre!!

```{r, echo=FALSE, fig.align='center', out.width='30%'}
knitr::include_graphics("img/Rlogo.png")
```

Ainda por ser uma *linguagem de programação*, poder ser estendido (implementado) 
por meio de **pacotes** (*packages*) que facilitam (e muito) nosso fluxo de 
trabalho nele.

> Um pacote é constituido de funções e objetos do `R`.

Pacotes facilitam rotinas!
Isso para que não precisemos reperir um conjunto de códigos, geralmente extenso, 
em atividades rotineiras.

Na instalação do `R`, já vem disponíveis 7 (sete) pacotes:

stats | graphics | grDevices | utils | datasets | methods | base
 ---  | ---      | ---       | ---   | ---      | ---     | ---

Estes são carregados automaticamente.
Os outros deverão ser instalados e carregados convenientemente (falaremos disso mais adiante, no curso).

### 3.1.2 Palavras iniciais sobre o tidyverse

Um dos inúmeros pacotes implementados para o `R` é o 
[**tidyverse**](https://www.tidyverse.org/). 

```{r, echo=FALSE, fig.align='center', out.width='30%'}
knitr::include_graphics("img/tidyverse.png")
```

Este se destaca por ser um conjunto de outros pacotes amplamente usados para 
análise de dados, fornecendo uma uniformidade na escrita de comandos, bem como 
uma comunidade ativa em sua implementação.

> Tidyverse: um conjunto de pacotes para análise de dados

Nesse minicurso, **usaremos o** `R` **na perspectiva do** ***tidyverse***.
Então, não será nosso objetivo um aprofundamento na linguagem `R` (que é algo 
muito maior e demandaria muito tempo).
Apenas falaremos, brevemente, sobre aspectos essenciais dessa linguagem que 
utilizaremos nos pacotes do *tidyverse*.

Esse texto foi planejado para aprenderemos alguns aspectos básicos da linguagem 
`R` que nos fornecerão instrumentos para o desenvolvimento da extração de dados
na web com as ferramentas e linguagem do *tidyverse*.

Vamos começar?

## 3.2 R como uma super calculadora

O `R` pode ser usado como uma excelente calculadora!
Sim! 
Você pode *somar* (`+`), *subtrair* (`-`), *multiplicar* (`*`) e *dividir* (`/`)
dois números reais, dentro do dominio dessas operações.

Existem outras funções matemáticas notáveis que certamente serão úteis em muitos
aspectos:

 codigo       |  saída        | nome
:------------:| :-------:     | :-----:
`a ^ b`       | $a^b$         | $a$ evelado a $b$
`sqrt(x)`     | $\sqrt{x}$    | raiz quadrada de $x$
`exp(x)`      | $\exp{x}$     | exponencial de $x$
`log(x)`      | $\ln{x}$      | logarítimo natural de $x$
`log10(x)`    | $\log{x}$     | logarítimo de $x$ na base 10
`log(x, b)`   | $\log_{b}{x}$ | log de $x$ na base $b$

Usando as funções adequadas, podemos calcular a expressão abaixo:
$$\log{(\exp{1})} + 3^2 - \sqrt{100}.$$

Para isso, podemos usar o código:

```{r, echo=TRUE}
log(exp(1)) + 3 ^ 2 - sqrt(100)
```

Mas, não para por aí!
O `R` também é, principalmente, uma excelente calculadora estatística!
Existem testes e funções específicas que auxiliam muito as análises estatísticas
para qualquer conjunto de dados.
Vale a pena um aprofundamento depois desse minicurso!

### 3.2.1 Atribuição, no R

O simbolo `<-` ("menor do que" com "menos", justapostos) serve para fazermos 
atribuições de objetos no `R`.
Tais atribuições seguem o sentido da "seta", ou seja, supondo que "a" seja um 
número real, ao escrever `x <- a` significa que "x" assume o valor de "a".
Mas, obviamente, "a" pode ser um *vetor*, uma *matriz*, uma *lista*, etc.

Isso é útil para trabalharmos com grandes informações usando apenas um símbolo, 
ou nomenclatura adequada.

Mas, vamos começar com coisas pequenas nesse minicurso, não?

Se fizermos 

- `a <- log(exp(1))`; 
- `b <- 3^2`;
- `c <- -sqrt(100)`;

ao somarmos `a + b + c` deve retornar o mesmo valor da solução do exercício 
anterior, a saber, 0 (zero).

```{r, echo=TRUE}
a <- log(exp(1))
b <- 3^2
c <- -sqrt(100)

a + b + c
```

Observe que, quando atribuimos um valor a um objeto, ele fica "armazenado".
Para aparecer, deve retornar o objeto novamente.

```{r, echo=TRUE, eval=FALSE}
um_objeto <- 7
um_objeto
```

#### 3.2.1.1 Exemplificando

Vamos usar o que aprendemos com a ferramenta "atribuição", para conhecermos a
função `download.file()`, que pertence ao pacote `utils` (já incluso no R Base).

Essa função possui, por exemplo, a seguinte estrutura:

```{r, eval=FALSE}
download.file("url", "destino/nome-e-extensao-do-arquivo", mode = "xx")
```

Onde,

- **url**: é o *link* do arquivo que você deseja fazer o *download*;
- **destino/nome-e-extensao-do-arquivo**: diretório (pasta) e o nome do arquivo
  explicitando a sua extensão. 
  A barra "/" delimita o caminho relativo;
- **mode**: por padrão é "w", para arquivos de texto plano. 
  Mas, se for, por exemplo, arquivos `.pdf`, deve-se colocar o argumento "wb" 
  (arquivos binários).

Vamos fazer dois exemplos para deixar claro as coisas:

<details>
  <summary>
    **Exemplo 01:**  *download* de arquivo `.R`
  </summary>
  
Vamos fazer o *download* do arquivo de texto `CIR.00_apresentacao.R`, que se encontra 
na página:

<p align='center'>
  https://lec.pro.br/avale-es/r
</p>

Vamos atribuir à variável `url_uesc` o endereço do *link* desse arquivo (notem 
as aspas):

```{r}
url_uesc <- "https://lec.pro.br/download/R/cir/CIR.00_apresentacao.R"
```

Além disso, vamos determinar que o arquivo "CIR.00_apresentacao.R" seja colocado 
na pasta "arquivos_teste".
Logo, depois de criar esse diretório, podemos fazer a seguinte atribuição para o 
caminho relativo desse arquivo:

```{r}
destino_arquivo <- "arquivos_teste/CIR.00_apresentacao.R"
```

Portanto, o *download* pode ser feito assim:

```{r, eval=FALSE}
download.file(url_uesc, destino_arquivo)
```

</details>

<details>
  <summary>
    **Exemplo 02:** *download* de arquivo em `.pdf`
  </summary>
  
  Abaixo encontram-se a nossa `url` e `destino-do-arquivo`:
  
```{r}
url_sbm <- "https://sbm.org.br/wp-content/uploads/2021/10/belos-problemas-de-matematica_ebook.pdf"

destino <- "arquivos_teste/belos-problemas.pdf"
```

Agora, se você usa o sistema operacional Windows, para que seja feito o *download* 
corretamente precisamos colocar o argrumento `mode = "wb"`:

```{r, eval=FALSE}
download.file(url_sbm, destino, mode = "wb")
```

Depois, apenas por curiosidade, tente fazer esse *download* sem passar o argumento
`mode = "wb"` ...
O que aconteceu com o conteúdo do PDF?

</details>

Ainda falando sobre atribuições, podemos armazenar uma cadeia de caracteres, 
como uma frase.
Por exemplo:

```{r}
musica <- "Pois tê-Lo e nada mais, não é menos que tê-Lo e tudo o mais"
```

Em alguns casos, é conveniente retirarmos toda a acentuação de uma frase, ou 
conjunto de caracteres.
O R Base possui uma função muito conveniente para isso: `iconv()`.
Ela possui alguns argumentos, todavia usaremos apenas dois: o objeto que queremos
mudar a codificação; e, a codificação que desejamos (sem acentuação).
No que se refere a codificação sem acentuação, podemos "transliterar" a frase
usamos usando `ASCII//TRANSLIT`, no argumento `to = `. 
O código ficaria assim:

```{r}
iconv(musica, to = "ASCII//TRANSLIT")
```

**Obs.:** O `tidyverse`, por meio do pacote `stringi` fornece uma função semelhante:
`stri_trans_general()`, que podemos passar o argumento `"Latin-ASCII"`; ou seja,
poderíamos, para o exemplo acima, usar `stringi::stri_trans_general(musica, "Latin-ASCII")`.

## 3.3 Operadores Lógicos

Os seguintes operadores lógicos serão de muita importância na escrita de nossos 
códigos, em análises futuras:

Operadores | Descrição
---------- | ----------
`a == b`   | $a$ é **igual** a $b$
`a != b`   | $a$ é **diferente** de $b$
`a < b`    | $a$ é **menor do que** $b$
`a > b`    | $a$ é **maior do que** $b$
`a <= b`   | $a$ é **menor ou igua a** $b$
`a >= b`   | $a$ é **maior ou igua a** $b$
`a & b`    | Ocorre $a$ **e** $b$ (simultaneamente)
`a | b`    | Ocorre $a$ **ou** $b$ (união)

Eles retornarão, algum dos seguintes valores lógicos:

- `TRUE`: valor lógico **Verdadeiro**;
- `FALSE`: valor lógico **Falso**.

Ou relacionarão variáveis numa `tibble` (falaremos sobre isso em outra 
oportunidade).

## 3.4 Tipos de dados

Quando nos deparamos com dados, as variáveis que os representam podem ser, 
basicamente: *quantitativas* (fruto de alguma medição, ou relacionado a contagem) 
ou *qualitativas* (relacionadas a algum atributo).

> Variáveis **quantitativas** também são chamadas de **numéricas**. </br>
Variáveis **qualitativas** também são chamadas de **categóricas**.

O `R` possui uma forma própria de relacionar esses dados e os separam em algumas 
categorias, por exemplo:

- *numeric* (**numéricos**); são os números reais (1, 1/2, $\sqrt{3}$, $\pi$, etc.)
- *integer* (inteiros); devemos colocar "L" ($1L$, $2L$, etc.)
- *complex* (números complexos); representados assim: $1+3i,\, 5+i\sqrt{5}$, etc.
- *character* (**caracteres**); sempre entre aspas ("1", "Olá pessoal!", "3<4", 
  "livros", etc.)
  + *factor* (fatores) quando há ordenação por níveis ("classe baixa", 
  "classe média", "classe alta")
- *logical* (lógicos) quando relacionamos objetos com algum operador lógico (
  `1 == 3`, `2 < 7`, `"olá" != "ola"`)
)

Em nosso minicurso, grande parte dos dados serão *numeric* ou *character*.

## 3.5 Estruturas dos dados

No `R` existem várias estruturas para armazenamento de dados.
Podemos armazenar em linha, tabela e até em formato espacial.
Algumas dessas estruturas são mostradas abaixo:

- **Vetores.** Estruturas unidimensionais. 
  Usamos a função *concatenar*, `c()`, para criar um vetor. </br> 
  **Obs.:** Num vetor, seus elementos devem ser todos do mesmo tipo;
- **Matrizes.** Estruturas de dados bidimensionais. 
  Usamos o comando `matrix(x, nrow = m, ncol = n )`.
- **Listas.** Estrutura mais gerais de armazenamento. 
  Em uma *lista* pode conter um vetor, uma matriz, um data frame ou, até mesmo, 
  outras listas! 
  Usamos o comando `list(var1 = ..., var2 = ..., ...)`
- **Data Frames.** É um caso especial de *lista*. 
  "Data Frame" significa "quadro de dados", ou seja, a ideia é de uma tabela em 
  que as linhas representam observações e as diferentes variáveis definem as 
  colunas. 
  Usamos o comando `data.frame(var1 = ..., var2 = ..., ...)`. </br>
  **Obs.:** Num Data Frame, o número de linhas deve ser o mesmo em cada variável 
  (coluna). 

Nesse minicurso, precisamos saber um mínimo sobre **vetores** e **listas**, de 
forma direta; e sobre **data frames**, de forma indireta (pois aprenderemos uma
forma melhorada de um *data frame* que será uma *tibble*, disponibilizada por um 
dos pacote do `tidyverse`, a saber, de mesmo nome: `tibble`).
Logo, vamos conhecer um pouco mais sobre os dois primeiros, agora.

### 3.5.1 Vetores

Aqui a ideia não é apenas matemática, mas qualquer agrupamento simples de objetos
que sejam números ou caracteres.
Devemos lembrar que a separação dos elementos é dada por "vírgula" e a separação
decimal com "ponto".

Abaixo um vetor numérico:

```{r}
notas <- c(4.28, 4.71, 4.06, 5.30, 5.28, 4.76, 4.66, 4.91, 4.18, 5.34)
notas
```

Se quisermos selecionar o terceito elemento desse objeto, usamos:

```{r}
notas[3]
```

Considere, agora, um vetor de caracteres:

```{r}
dias_da_semama <- c("dom", "seg", "ter", "qua", "qui", "sex", "sab")
dias_da_semama
```

Uma pergunta que surge é: e se misturarmos os dois?

```{r}
misto <- c(1, "1")
class(misto)
```

No código acima, temos um "vetor" com o primeiro argumento sendo numérico e o 
segundo como caractere.
Mas, a classe desse objeto em `R` foi definida como "character".

Se quisermos algo que armazene dados numéricos ou categóricos, precisamos da 
classe *list* (lista), do `R`.

### 3.5.2 Listas

As listas são estruturações mais gerais do `R`, pois podem conter outros
agrupamentos já vistos, bem como outra lista!!

O comando para criar uma lista é `list()`.

```{r}
lista <- list(numerico = c(1), caractere = c("1"))
lista
class(lista)
```

Note, no exemplo acima, que criamos uma lista com dois objetos de tipos diferentes:
um "numeric" e outro "character".

No próximo exemplo, considere uma lista (`lista_mae`) que é composta de outras 
quatro listas (`data`, `nome`, `despesa`, `cargo`):

```{r}
# nomeando as listas
data <- c("2021-10-01", "2021-09-01", "2021-08-01", "2021-07-01")
nome <- c("Asponjo", "Luderval", "Chinchila", "Locobel")
despesa <- c(2000, 800, 1000, 6000)
cargo <- c("prefeito", "acessor", "vereador", "advogado")

# criando a lista_mae  
lista_mae <- list(data, nome, despesa, cargo )
```

Para selecionarmos os elementos da `lista_mae`, mantendo-os dentro da estrutura 
da mesma, usamos `[]` (calchetes simples).

```{r}
lista_mae[1]
```

Se quisermos selecionar os elementos, sem depender da hierarquia da lista, usamos
`[[]]` (colchetes duplos):

```{r}
lista_mae[[1]]
```

A diferença é sutil, mas crucial.

Para perceber essa diferença, suponha que você queira acessar o segundo elemento
da `despesa`, ou seja, o elemento "800".
Para isso, precisamos usar `lista_mae[[3]]` para selecionarmos os elementos da
`despesa` e, para escolher o segundo elemento dessa estrutura, colocamos 
`lista_mae[[3]][2]`.

Veja na prática:

```{r}
lista_mae[3][2]
```

```{r}
lista_mae[[3]][2]
```

Agora, se quisermos selecionar uma sequência de objetos da `lista_mae`, por 
exemplo, de `nome` até o `cargo`, podemos usar `lista_mae[2:4]`:

```{r}
lista_mae[2:4]
```

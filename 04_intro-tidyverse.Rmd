---
title: "O que usaremos do Tidyverse?"
description: |
  Explanação sucinta (apenas) das funções que usaremos do tidyverse & Cia.
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
xaringanExtra::use_panelset()
library(magrittr)
```


# 4. Algo a mais sobre o Tidyverse

## 4.1 O universo arrumado do tidyverse

Vimos que o `tidyverse` é um pacote do R que agrega pacotes com uma certa 
"filosofia", por exemplo, o modo de escrever as funções (geralmente com verbos
em inglês que remotam à característica dessa função).

São muitos os pacotes que compõem o `tidyverse` (30 pacotes). 
Podemos listá-los com o seguinte comando:

```{r}
tidyverse::tidyverse_packages()
```

Entretanto, usaremos, apenas, sete desses pacotes nesse minicurso:

- **readr**; usaremos a função `parse_double()` que, como o nome sugere, 
  passa um conjunto de caracteres para a categoria numérica. 
  Uma função do R Base que poderia fazer o mesmo papel seria `as.numeric()`.
  também usaremos a função `write_csv()`, para formarmos uma saída com arquivo 
  de extensão `csv`.
- **tibble**; para construirmos "tabelas" (`tibbles`) especiais e visualizarmos 
  o resultado.
- **dplyr**; para manipulação de dados (agrupar, selecionar, filtrar, arrumar, 
  etc., certas características desejadas nas `tibbles`)
- **stringr**; para manipulação de cadeias de caracteres, como frases, texto, 
  símbolos, etc. 
  É bem útil para "limpeza" dos dados coletados numa raspagem da internet (as 
  coisas, geralmente, não vem "arrumadinhas").
- **stringi**; apenas usaremos a função `stri_trans_general()`, com o argumento
"Latin-ASCII", para retirar a acentuação das palavras.
- **purrr**; para interações. Substitui as ideias das estruturas de repetições 
  (`loops`) na programação, como `for` ou `while`, por exemplo. 
- **rvest**; para raspagem de dados em documentos html. 
  É o principal pacote de nosso minicurso.

No que se refere à utilização desses pacotes, podemos escolher algumas arbordagens...

Uma delas é carregar todo o pacote `tidyverse`  na memória do computador.
Mas, isso carrega, apenas, uma parte dos pacotes, como vocês podem perceber ao
digitarmos:

```{r, message=TRUE}
library(tidyverse)
```

Note que foram carregados 8 (oito) pacotes:

```{r, fig.align='center', echo=FALSE, out.width='90%'}
knitr::include_graphics("img/packages_tidyverse.png")
```

E o `rvest` não está nessa lista.
Então, precisaremos carregá-lo também!

```{r, eval=FALSE}
library(tidyverse)
library(rvest)
```

Essa é uma abordagem válida e simplifica a escrita dos códigos, tornando-os menos
"verbosos".
Uma desvantagem, porém, é que, quando se é iniciante, nem sempre conhecemos de 
qual pacote pertence determinada função, o que pode atrapalhar os estudos.
Além, claro, de carregar a memória do computador com pacotes que não usaremos.

Dessa forma, podemos usar a seguinte abordagem (que usarei no minicurso):
não carregaremos o pacote todo (ou seja, não usaremos `library(nome-do-pacote)`),
mas as funções provenientes deles. 
Para isso, usaremos a seguinte nomenclatura:

```{r, eval=FALSE}
pacote::nome_funcao()
```

### 4.1.1 Uso dos pipes

A ideia do "pipe" (existem diversas traduções, mas a que me faz comprender a ideia 
é a de “tubo”, como em uma “encanação”: você conecta as coisas) é, basicamente, 
escrever o encadeamento do código como pensamos; bem como escrevê-lo em etapas 
sutilmente delimitadas, trazendo clareza em cada linha de código.

O tidyverse, por meio do pacote `magrittr`, disponibiliza o pipe `%>%`, que pode
ser acessado por meio do comando `Ctrl + Shift + M`.

Para entendermos um pouco mais sobre o `%>%`, lembremos das funções compostas. 
Ao compormos três funções, por exemplo, escrevemos:

\[
  h(g(f(x)))
\]

Resolvemos, então, de “dentro” para “fora” da expressão, ou seja, calculamos 
$f(x)$, depois $g(f(x))$ e, por fim $h(g(f(x)))$.

Mas, nosso raciocínio é mais ou menos assim:

1. "pegue o $x$, **então**
2. aplique em $f()$, **então**
3. aplique em $g()$, **então**
4. aplique em $h()$.

Podemos expressar esse mesmo pensamento usando o `%>%`, da seguinte forma:

```{r, eval=FALSE}
x %>% f() %>% g() %>% h()
```

Ou, na prática, escrevemos assim:

```{r, eval=FALSE}
x %>% 
  f() %>% 
  g() %>% 
  h()
```

Onde $x$ representa, geralmente, algum conjunto de dados (dataset) ou conjunto 
de caracteres; e, as funções $f$, $g$, $h$ são algumas das funções dos pacotes 
do tidyverse.

Por exemplo, suponha que num `site` leia-se o código *html*, usando a função
`read_html()`; extraia-se os elementos da *tag* `a`, usando a função 
`html_elements()`; e, por fim, extraia-se o atributo que armazena os *hiperlinks*
("href"), com a função `html_attr()`.

A sequêcia dos códigos ficaria assim:

```{r, eval=FALSE}
site |> 
  rvest::read_html() |> 
  rvest::html_elements("a") |> 
  rvest::html_attr("href")
```

Ôpa! 
O pipe não era `%>%`? 
Por que apareceu `|>`?

O pipe introduzido pelo tidyverse foi tão bem aceito, que o próprio R Base decidiu
implementar um.
O pipe `|>` é mais rápido do que o `%>%`, porém, se precisarmos passar dois 
argumentos numa mesma função, o pipe `%>%`  é mais conveniente.

> Logo, podemos usar de forma indiscriminada qualquer dos pipes, desde que seja
conveniente para os fins que desejamos. 
> Em especial, nesse minicurso, daremos preferência ao uso do pipe base, `|>`.
> Só usaremos o pipe do `magrittr`, `%>%`, se houver a necessidade de passarmos
dois argumentos numa mesma função.

No RStudio Cloud, por padrão, vem o pipe `%>%`.
Você não precisa alterar nada para acompanhar o minicurso!

## 4.2 Pacotes que usaremos

Vamos, agora, falar um pouco sobre as funções que usaremos nesse minicurso, 
contextualizando-as em seus respectivos pacotes.

### 4.2.1 tibble

Uma `tibble` é um `data frame` (do R Base) melhorado.
Grosso modo, é uma tabela muito especial.
Com ela, podemos organizar os dados de uma forma que facilite a manipulação dos
mesmos pelos pacotes do tidyverse e para o processamento no computador.
Para quem possuir interesse, o formato da `tibble` em questão é o
[tidy](https://vita.had.co.nz/papers/tidy-data.html), onde cada coluna representa
uma *variável*; cada linha, uma *observação*; e, em cada célula há *apenas* uma
observação.

Para nossos fins, basta saber como formar uma `tibble` e como visualizá-la.

A função `tibble()`, do pacote de mesmo nome, `tibble`, cria a tabela desejada.
A estrutura dessa função segue o formato:

```{r, eval=FALSE}
tibble::tibble(
  var_1 = ...,
  var_2 = ...,
  ...
  var_n = ...
)
```

Por exemplo, suponha que desejamos construir uma tabela com três variáveis:
`livro`, `preco_antigo` e `preco_novo`.
Podemos construir uma `tibble` com:

```{r}
tabela_livros <- tibble::tibble(
  livro = c("Álgebra", "Geometria", "Análise"),
  preco_antigo = c("R$ 45.99", "R$ 30.50", "R$ 80.00"),
  preco_novo = c("R$ 32.1", "R$ 25.50", "R$ 72.00")
)

tabela_livros
```

Notem que a visualização é feita no console do RStudio.
Caso queiramos uma visualização mais aprimorada, podemos usar a função `view()`,
da seguinte forma:

```{r}
tabela_livros |> tibble::view()
```

A saída assemelha-se a isso (só dá para visualizar no RStuido):

```{r, echo=FALSE, fig.align='center'}
knitr::include_graphics("img/tibble.png")
```

### 4.2.2 readr

O `readr` possui funções direcionadas para leitura de dados (`csv`, `tsv` e `fwf`).
Todavia, existe uma função, que usaremos em determinadas passagens, para transformar
a classe dos dados para **numérica** (*numeric* ou *double*).

O nome dessa função é **parse_double()**.

Vejamos um exemplo.

Suponha que numa extração de dados da *web*, os valores de três livros fossem 
classificados como "character", mas, obviamente, gostaríamos que eles fossem 
"numeric".

```{r}
valores_web <- c("20.2", "30.1", "23.5")

class(valores_web)
```
Para transformar esses valores para dados numéricos, usamos:

```{r}
valores_num <- valores_web |> 
  readr::parse_double()
```

Transformamos e salvamos na variável `valores_num`.
Ao verificarmos a classe, percebemos que os dados passaram a ser numéricos:

```{r}
class(valores_num)
```

Dentro desse mesmo pacote há a função `write_csv()`.
Ela possui a seguinte estrutura:

```{r, eval=FALSE}
write_csv(variavel-formada, "caminho/nome-com-extensao.csv")
```

Onde, `variavel-formada` é algum objeto (_data-frame_, por exemplo) que você 
atribuiu à alguma variável e deseja salvar em `.csv`; e, `"caminho/nome-com-extensao"` 
(notem as aspas!) é o caminho relativo que deseja-se "escrever" esse arquivo no 
disco.

Por exemplo, suponha que nosso objetivo seja salvar a `tibble` **tabela_livros** 
no diretório `downloads` (dentro de sua área de trabalho no R).
Basta, então, fazermos:

```{r, eval=FALSE}
write_csv(tabela_livros, "downloads/tabela-livros.csv")
```

Note que dei o mesmo nome "tabela_livros" ao arquivo formado.

### 4.2.3 dplyr

O pacote [dplyr](https://dplyr.tidyverse.org/) fornece uma estruturação de funções
que seguem uma certa "gramática de manipulação de dados". 
Isso fornece um conjunto consistente de "verbos" (os nomes das funções são verbos
, em Inglês, que lembram a sua utilidade) que resolvem os desafios mais comuns 
na manipulação de dados.

É um pacote fabuloso e que precisaríamos de um curso só para falar dele.

Como o objetivo desse minicurso é sobre Web Scraping, a manipulação dos dados
estará contida no processo.
Entretanto, manipularemos conjuntos de caracteres e não necessariamente "tibbles".
Portanto, só usaremos algumas poucas funções desse pacote.

Uma delas é a função **mutate()**.

Em inglês, numa tradução livre, a palavra *mutate* refere-se a "mudança", 
"alteração", etc.
Portanto, usaremos a função `mutate()` se desejamos fazer uma modificação na
tibble (usamos `dplyr` apenas em tibbles).

Para exemplificar, considere a seguinte tabela (modificamos a tabela anterior 
para que as variáveis fossem numéricas):

```{r}
tabela_livros_mod <- tibble::tibble(
  livro = c("Álgebra", "Geometria", "Análise"),
  preco_antigo = c(45.99, 30.50, 80.00),
  preco_novo = c(32.1, 25.50, 72.00)
)
```

Se quisermos acrescentar uma variável que calcula a diferença entre o "preço novo" 
(`preco_novo`) e o "preço antigo" (`preco_antigo`) precisamos usar o `mutate`.
Ela acrescentará uma nova variável (que daremos o nome `diferenca`) à `tabela_livros_mod`.

```{r}
tabela_livros_completa <- tabela_livros_mod |> 
  dplyr::mutate(
    diferenca = preco_novo - preco_antigo
  )

tabela_livros_completa
```

> Observe que, para fazer sentido a diferença entre os valores, estes devem ser
numéricos!

Agora, suponha que desejamos criar uma nova variável que estabeleça uma 
"tomada de decisão".
Se o "preço novo" for 30% mais barato do que o "preço antigo", deseja-se que apareça 
a mensagem "compre".
Caso contrário, deseja-se que apareça a mensagem "aguarde".

Para isso, como podemos notar, precisamos usar uma estrutura "if ..., else", ou
seja, "se ocorre '*condição A*', então '*faça B*'; caso contrário, '*faça C*'".

O `dplyr` fornece uma função para isso: `if_else(cond., caso-verdade, caso-contrário)`.

- No argumento `cond.`, colocamos a condição desejada;
- No argumento `caso-verdade`, colocamos a mensagem caso a condição desejada seja
  verdadeira;
- No argumento `caso-contrário`, colocamos  a mensagem caso a condição inicial 
  não seja satisfeita.

Portanto, o código fica assim:

```{r}
tabela_livros_decisao <- tabela_livros_mod |> 
  dplyr::mutate(
    decisao = dplyr::if_else(
      preco_novo <= 0.7 * preco_antigo, "compre", "aguarde"
    )
  )

tabela_livros_decisao
```

### 4.2.4 rvest

Esse é o principal pacote que usaremos para o *web scraping*.
Ele será responsável por "ler" os códigos html que cada página dispõe, extraindo 
os "elementos" que desejamos.

Abordaremos, de forma direta, algumas das funções desse pacote.
Para isso, vamos usar como exemplo o seguinte texto em html:

```{r,eval=FALSE}
<html>
  <head>
    <title>Web Scraping</title>
  </head>
  <body>
    <h1>Web Scraping com R</h1>
    <h2>Seção 01: Lista de links</h2>
      <p>Lista de links </p>
      <ul>
        <li><a href='https://www.mathunion.org/'> União Internacional de Matemática (IMU)</a></li>
        <li><a href='https://sbm.org.br/'> Sociedade Brasileira de Matemática (SBM)</a></li>
        <li><a href='https://www.sbmac.org.br/'> Sociedade Brasileira de Matemática Aplicada e Computacional (SBMAC)</a></li>
      </ul>
    <h2>Seção 02: Uma imagem</h2>
    <p>Apenas uma imagem de uma Arte Matemática.</p>
    <p align='center'>
    <img width='200' src='https://www.pinclipart.com/picdir/middle/374-3743859_drawing-geometry-line-art-triangle-vortex-clipart.png'>
    </p>
    <h2>Seção 03: Uma tabela</h2>
    <p> Aqui vou colocar uma tabela em html.</p>
    <table>
      <tr>
        <td><b>nome</b></td>
        <td><b>preco_antigo</b></td>
        <td><b>preco_novo</b></td>
        <td><b>decisao</b></td>
      </tr>
      <tr>
        <td>Álgebra</td>
        <td>R$ 45,99</td>
        <td>R$ 32,10</td>
        <td>compre</td>
      </tr>
      <tr>
        <td>Geometria</td>
        <td>R$ 30,50</td>
        <td>R$ 25,50</td>
        <td>aguarde</td>
      </tr>
      <tr>
        <td>Análise</td>
        <td>R$ 80,00</td>
        <td>R$ 72,00</td>
        <td>aguarde</td>
      </tr>
    </table>
  </body>
  
</html>
```

Ele está diponível (o código, não a saída) no link abaixo:

<p align='center'>
  <a src='https://git.io/JMTRO'> https://git.io/JMTRO </a>
</p>

O link dese site foi reduzido, usando o encurtador [https://git.io/](https://git.io/),
do GitHub.
Mas, geralmente, os links podem vir bem extensos.
Para simplificar essa situação, atribuímos à variável `site` a url que desejamos
analisar (veja que salvamos **entre aspas**, ou seja, em formato de caracteres):

```{r}
site <- "https://git.io/JMTRO"
```

A saída desse código é dada a seguir:

```{r, fig.align='center', echo=FALSE}
knitr::include_graphics("img/site_print.png")
```

O primeiro passo é fazer com que o R "leia" (importe) os dados do html para a 
memória do computador (ou, no caso desse minicurso, para o servidor do RStudio 
Cloud).
Fazemos isso com a função **read_html()**.

Nesse ponto, cabe uma consideração: geralmente extraimos mais de um elemento de
uma página web, mas a leitura do html é a mesma.
Portanto, salvar esse passo inicial em alguma variável é conveniente.
Vamos denominar essa variável por **site_base**.

O código fica assim:

```{r}
site_base <- rvest::read_html(site)

site_base
```

Notem que o documento possui duas partes: **head** e **body**.
Como vimos, o que precisamos, encontra-se na *tag* **body**.
Antes de prosseguirmos, retorne ao código em html e procure encontrar *tags* como
"h1, h2, ...", "a", "p", "img", "table", etc.

Suponha que desejamos extrair a tabela dessa página de exemplo.
A função para isso é **html_table()**.

```{r}
tabela <- site_base |> 
  rvest::html_table()

tabela
```
A saída é uma `tibble` pronta para ser manipulada (você pode estudar sobre o 
`dplyr` pra isso)!
Mas, o "cabeçalho" dessa tabela não ficou como desejamos: a segunda linha deveria
ser esse cabeçalho.

Você pode usar o argumento `header = TRUE`, na função `html_table()` para que 
a extração da tabela seja adequada aos nossos fins.

```{r}
tabela <- site_base |> 
  rvest::html_table(header = TRUE)

tabela
```

E se nosso objetivo fosse extair os elementos que contém os links e textos que 
estão na "Seção 01: ..."?
Ora, vimos que os links encontram-se na *tag* "a" (de *anchor*, ou seja, âncora).
Então, nada mais adequado do que extraírmos esse elemento.
Para isso, usamos a função **html_elements()**

```{r}
site_base |> 
  rvest::html_elements("a")
```

Aqui precisamos decidir ... 
Se quisermos extrair:

- a **url**; usamos a função **html_attr()**, com o atributo "href";
- o **texto**; usamos a função **html_text2()**.

```{r}
# extraindo todas as urls -----------------------------------------------------
site_base |> 
  rvest::html_elements("a") |> 
  rvest::html_attr("href")
```

```{r}
# extraindo o texto da tag "a" ------------------------------------------------
site_base |> 
  rvest::html_elements("a") |> 
  rvest::html_text2()
```

#### 4.2.4.1 Sobre o pacote httr

Quando tentamos extrair informações de alguns sites, certos erros de certificados
podem aparecer e os motivos são variádos (veja mais informações 
[aqui](https://br.godaddy.com/blog/erros-no-certificado-ssl/)).

Para sanar essa dificuldade, caso apareça algum erro de certificação SSL, devemos
colocar, antes da leitura do html, um comando que desativa a verificação dos
certificados SSL.
O pacote `httr` fornece a função `GET()`, para requisição da url e a função 
`config()`, para passarmos os parâmetros desejados (que, no nosso caso, seria 
**ssl_verifypeer = FALSE**, ou seja, não queremos verificar o certificado SSL).

Em resumo, coloque assim a linha de código (quando estiver atribuindo à variável
`site_base`):

```{r}
site_base <- site |> 
  httr::GET(httr::config(ssl_verifypeer = FALSE)) |> 
  rvest::read_html()
```
E todo o resto, faça como vimos anteriormente.

### 4.2.5 stringr

Esse pacote é essencial para limpeza dos dados.
Sim ... os dados não chegam para nós "arrumadinhos"!
Ao contrário, na maioria das vezes, os conjuntos de dados possuem caracteres não 
formatados, ou simplesmente não estão como desejamos organizar.

De fato, quando fazemos uma "raspagem de dados", estamos trabalhando com 
"fragmentos de textos".
Manipular esses fragmentos é fundamental para que as análises sejam realizadas
sem muitos "sustos" (geralmente não sai como desejamos quando, por exemplo, um
caractere especial está presente numa extração realizada).

Seremos diretos ao abordar as funções desse pacote, usadas nesse curso.
Antes, é interessante destacar que, tal como no pacote `rvest`, as funções do
pacote `stringr` seguem determinada estruturação.
Por exemplo, a maioria de suas funções começam com **str_** (no `rvest`, a maioria
começava com **html_**).

Para começarmos, considere a seguinte situação: desejamos extrair o preço dos
livros.

Ora, observando o código em html, vemos que a *tag* que nos ajudará nisso é a
**tb**.

```{r}
site_base |> 
  rvest::html_elements("td")
```
Bom ... tem coisa demais aí.
Quero o texto que se encontra entre as *tags*.
Então, usamos:

```{r}
site_base |> 
  rvest::html_elements("td") |> 
  rvest::html_text2()
```

Agora não temos mais funções do `rvest` para nos ajudar.
Precisamos manipular esses conjuntos de caracteres com o pacote **stringr**.

Como nosso objetivo é extrair os preços, percebemos que há um padrão: todos os
preços começam com "R$".
Há uma função no `stringr` que extrai uma sequência de caracteres que possui
determinado padrão.
É a função **str_subset()**.
Em seu argumento, colocamos, entre aspas, o padrão que desejamos.

Em nossa situação, cabe um detalhe: não adiantará (faça o teste) colocarmos 
`str_subset("R$")`, pois há um "caractere especial", a saber, "`$`".
Esse símbolo do cifrão é usado, no R, para fins específicos e, portanto, devemos
"escapar" o código na hora de escolhê-lo.
Fazemos isso com duas barras invertidas antes do cifrão.
Logo, devemos fazer: `str_subset("R\\$")`.
Assim:

```{r}
site_base |> 
  rvest::html_elements("td") |> 
  rvest::html_text2() |> 
  stringr::str_subset("R\\$")
```

Ótimo!
Mas, se desejamos apenas os valores numéricos, precisamos eliminar três caracteres: 
o "R", o "`$`" e o "espaço vazio"!).

A função **str_sub()** nos ajudará nessa questão.
Sua estrutura é dada por:

```{r, eval=FALSE}
stringr::str_sub(string, start = ..., end = ...)
```

Onde,

- *string*, é o conjunto de caracteres que estamos analisando;
- *start = ...*, é o ponto que iniciaremos a extração. 
  Devemos colocar aqui o número da posição do caractere que desejamos começar!
- *end = ...*, é o ponto que desejamos parar. 
  Se não colocarmos nada, subentende-se que iremos extrair até o final da *string*.

Portanto, como queremos eliminar os três primeiros caracteres, vamos iniciar a 
extração a partir do 4º caractere:

```{r}
site_base |> 
  rvest::html_elements("td") |> 
  rvest::html_text2() |> 
  stringr::str_subset("R\\$") |> 
  stringr::str_sub(4)
```

Muito bom, não?

Mas, ainda temos um problema: quando trabalhamos com valores numéricos, o 
separador decimal, por padrão, é o "ponto" e não a "vírgula".
Logo, seria importante subtituírmos todos os pontos por vírgula!
Fazemos isso com a função `str_replace_all()`.
Sua estruturação é:

```{r, eval=FALSE}
stringr::str_replace_all(string, "padrão", "substituição")
```

Onde:

- *string*, é o conjunto de caracteres analisado;
- *padrão*, é o caractere que deverá ser substituido;
- *substituição*, é o novo caractere que desejamos manter por padrão.

Em nosso caso, desejamos substituir a "vírgula" pelo "ponto", logo:

```{r}
site_base |> 
  rvest::html_elements("td") |> 
  rvest::html_text2() |> 
  stringr::str_subset("R\\$") |> 
  stringr::str_sub(4) |> 
  stringr::str_replace_all(",", ".")
```

Note que esse conjunto de dados não está ainda na forma numérica!
Sua classe ainda é "character".
Vimos que basta usarmos a função `parse_double()` do pacote `readr`:

```{r}
site_base |> 
  rvest::html_elements("td") |> 
  rvest::html_text2() |> 
  stringr::str_subset("R\\$") |> 
  stringr::str_sub(4) |> 
  stringr::str_replace_all(",", ".") |>
  readr::parse_double()
```

Com tudo o que vimos, já podemos fazer muitas coisas!
Mas, ainda precisamos falar sobre outras importantes funções desse pacote!

Uma situação que frequentemente acontece é colocarmos todas as letras em minúsculas.
A função **str_to_lower()** faz isso tranquilamente!

Para fins de exemplo, vamos colocar os nomes do texto que se encontra nos elementos
"a" em minúsculas.
Veja como fica o código:

```{r}
site_base |> 
  rvest::html_elements("a") |> 
  rvest::html_text2() |>
  stringr::str_to_lower()
```

Para exemplificar as duas últimas funções que usaremos desse pacote, considere
o seguinte conjunto de caracteres, denominado `livros_nome`:

```{r}
livros_nomes <- c(
  "Cálculo em uma Variável Complexa \n", 
  "introdução à álgrebra \r", 
  "Álgebra Linear \r"
)

livros_nomes 
```

Notem que há caracteres não desejáveis na extração: "`\r`" ou "`\n`".
Eles quebram a linha, colocando "espaços em branco" depois dos nomes).
Para eliminar esses "espaços em branco", usamos a função **str_trim()**.

```{r}
livros_nomes |> 
  stringr::str_trim()
```

Agora, vamos organizar as coisas ...
Vamos fazer o seguinte, pois retiramos os caracteres indesejados, mas os nomes 
não estão padronizados: 

1. colocar tudo em minúsculas;
2. retirar os espaços entre as palavras, substituindo-os por "traços" (-).
3. retirar a acentuação (com a função `iconv()`, do R Base).

O código fica assim:

```{r}
livros_nomes |> 
  stringr::str_trim() |> 
  stringr::str_to_lower() |>
  stringr::str_replace_all(" ", "-") |> 
  base::iconv(to = "ASCII//TRANSLIT")
```
Agora, suponha que desejamos colocar, no início de cada nome organizado de livros,
um padrão, por exemplo, "`livros-matematica_`".
Essa **concatenação**, ou justaposição de caracteres pode ser feita com a função
**str_c()**.
Assim, desejamos algo como: `str_c("livros-matematica_", .)`, onde "." representa
todas as expressões anteriores.

O código fica assim (note a mudança no pipe, para que seja mais simples mudar
o argumento para segunda posição):

```{r}
livros_nomes |> 
  stringr::str_trim() |> 
  stringr::str_to_lower() |>
  stringr::str_replace_all(" ", "-") |> 
  base::iconv(to = "ASCII//TRANSLIT") %>%
  stringr::str_c("livros-matemática_", .)
```

Temos, então, o suficiente do pacote `stringr` para nosso minicurso!

### 4.2.6 stringi

Do pacote `stringi` só usaremos a função `stri_trans_general()`, com o argumento
"Latin-ASCII".

Nem sempre a função `incov()` retorna convenientemente os dados, por isso usaremos
a função acima.

Veja o exemplo:

```{r}
# fazendo  um nome com muita acentução e exibindo -----------------------------
nome_doido <- "Àáäbcdéèëçã"
nome_doido

# usando a função stri_trans_general ------------------------------------------
stringi::stri_trans_general(nome_doido, "Latin-ASCII")

```


### 4.2.7 purrr

Por fim, mas não menos importante, precisamos de estruturas de *loops*.
Com efeito, quando efetuamos raspagem de dados em muitas páginas que seguem um
mesmo padrão, apenas com mofificações pontuais, uma estrutura de repetição, 
torna-se imperativa.

> No R Base existem os "for" e "while" da vida, mas o pacote `purrr` torna isso 
tudo mais simples!

A estruturação das funções do pacote `purrr` tem o seguinte formato:

```{r, eval=FALSE}
purrr::funcao_purrr(args, funcao)
```

Onde:

- **`funcao_purrr`**: é alguma função disponível no pacote. Existem muitas, mas
usaremos a `map_df()` que transforma a saída em um _data frame_ (na realidade
numa `tibble`);
- **`args`**: são os argumentos necessários para iteração. Dependendo da função,
pode haver mais de um argumento. Mas, para o nosso caso, será apenas um argumento.
- **`funcao`**: as funções do `purrr` iteram de acordo com a estrutura de uma 
"função" pré-determinada. Geralmente, criamos essa função com  o padrão de 
repetição que observamos ser necessário.

Pra explicarmos essas funcionaliddes, vamos criar um exemplo bem artificial, mas
adequado aos nossos fins.

Dado um número natural, suponha que deseja-se criar uma tabela que exiba:
na primeira coluna, o próprio número; e, na segunda coluna, o dobro desse número.

Por exemplo, se o número em questão for "3", queremos algo assim:

```{r, echo=FALSE}
tibble::tibble(
  numero = 3,
  dobro  = 6
)
```

Como montar uma função com essas ideias?
Simples: usaremos a estrutura do R Base `function(variável){estruturação}` com 
a função `tibble`, do pacote de mesmo nome.
Uma possibilidade seria:

```{r}
tabela_dobro <- function(x){
  tibble::tibble(
    numero = x,
    dobro  = 2 * (x)
  )
}
```

Veja que atribuímos à variável "`tabela_dobro`" a estrutura de função; logo, 
podemos usar tal variável, como se fosse uma função: `tabela_dobro()`.

Vamos testar para o caso do número "3", tal como fizemos anteriormente:

```{r}
tabela_dobro(3)
```

A saída é a mesma, não?

Mas, onde entre o `purrr`?

Suponha, agora, que desejamos aplicar nossa função criada para TODOS os naturais
de 1 até 10, agrupando-os em uma só tabela!
Para esse processo iterativo, usaremos a função `map_df()` do pacote `purrr`.
Antes, porém, devemos lembrar que essa sequência de números, pode ser obtida de
muitas maneiras, mas ficaremos com `1:10` (poderíamos usar a função `seq()`, do R
Base, da seguinte maneira: `seq(1, 10)`), por simplicidade.
Portanto, a iteração ocorre assim:

```{r}
purrr::map_df(1:10, tabela_dobro)
```

Massa, não?

### 2.2.8 fs

Por fim, por questções de organização, usaremos um pacote que não faz parte do 
`tidyverse`, mas que posui a mesma filosofia de sintaxe nas suas funções.
Com o pacote `fs` (de _File System_ ) podemos criar um diretório/pasta por meio 
de códigos em R, usando a dinção `dir_create()`; bem como extrair nomes de 
arquivos, com a função `path_file()`!

Por exemplo, o comando:

```{r, eval=FALSE}
pasta_arquivos <- fs::dir_create("downloads/pasta_arquivos")
```

Atribui à variável `pasta_arquivos` à criação de um subdiretório de mesmo nome 
(`pasta_arquivos`), dentro de um diretório por nome `downloads`.
Ele criará os dois diretórios, caso não existam, ou criará o subdiretório `pasta_arquivos` se `download` já exista.
)

O código abaixo mostra como usar a outra função considerada:

```{r}
# link do site, com nome do arquivo ao final (exrtensão .Rmd)
nome_arquivo <- "https://github.com/icaro-freire/minicurso_web-scraping/blob/feature/raspagem/04_intro-tidyverse.Rmd"
nome_arquivo

# usando a função path_dir()
fs::path_file(nome_arquivo)
```


Todas essas considerações, capacita-nos à raspagem dos dados!!!

